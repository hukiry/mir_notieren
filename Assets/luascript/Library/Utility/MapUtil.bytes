---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Administrator.
--- DateTime: 2022/5/2 17:27
---
---家园网格工具
---@class MapUtil
local MapUtil = {}

---世界坐标 转换 格子索引坐标
---@param worldPoint UnityEngine.Vector3
---@return number, number
function MapUtil.WorldToIndexCoord(worldPoint)
    local _x = Mathf.Round(worldPoint.x / Grid_WIDTH)
    local _y = Mathf.Round(worldPoint.y / Grid_HIGHT)
    return _x, _y
end

---格子索引坐标 转 世界坐标
---@param _x number
---@param _y number
---@return UnityEngine.Vector3
function MapUtil.IndexCoordToWorld(_x, _y)
    local x = _x * Grid_WIDTH
    local y = _y * Grid_HIGHT
    return Vector3.New(x, y,0)
end

---屏幕坐标 转 格子索引坐标
---@param mousePosition UnityEngine.Vector3 屏幕坐标
---@return number, number
function MapUtil.ScreenPositionToIndexCoord(mousePosition)
    local worldPos = Util.Camera().ScreenToWorldPoint(mousePosition);
    return MapUtil.WorldToIndexCoord(worldPos)
end

---格子二位坐标 转 世界坐标
---@param pos UnityEngine.Vector2Int
---@return UnityEngine.Vector3
function MapUtil.Vector2IntCoordToWorld(pos)
    return MapUtil.IndexCoordToWorld(pos.x, pos.y)
end

---是障碍物
function MapUtil.IsObstacle(x, y)
    ---1, 当前坐标未解锁格子
    if not Single.Grid():IsHaveGrid(x, y) then
        return true
    end

    ---2，当前坐标是有物品, 有云
    local info = Single.Grid():GetTileInfo(x, y)
    if info and (info.itemID > 0 or info.cloudState == 0) then
        return true
    end

    return false
end

---判断这个点是否可放置
---@return boolean true:可放置
function MapUtil.IsCanPlace(gx, gy, size)
    local isPlace = true;
    for x = 0, size - 1 do
        for y = 0, size - 1 do
            local isObstacle = MapUtil.IsObstacle(gx + x, gy + y)
            if isObstacle then  --查到某点是障碍的话，直接返回false
                return false
            end
        end
    end
    return isPlace
end

---查找附近的格子
---@param bx number 原始x的坐标
---@param by number 原始y的坐标
---@param size number 建筑大小
---@return boolean, number, number 是否找到位置, gx, gy
function MapUtil.FindNearGrid(size, bx, by)
    if size == 4 then
        return MapUtil.FindFullScreenPlace(size, bx, by)
    end

    local circleNum = 2 ---遍历圈，由内向外扩散
    for i = 1, circleNum do
        local nx, ny, mx, my = bx - i, by - i, bx + i, by + i
        for kx = nx, mx do
            for ky = ny, my do
                if math.abs(kx - ky) >= i and MapUtil.IsCanPlace(kx, ky, size) then
                    return true, kx, ky
                end
            end
        end
    end
    return false, bx, by
end

---全地图查找可放置坐标
---@param size number 建筑大小
---@return boolean, number, number 是否找到位置, gx, gy
function MapUtil.FindFullScreenPlace(size, bx, by)
    ---先拿到屏幕中心点
    local cx, cy = MapUtil.ScreenPositionToIndexCoord(Vector3.New(Screen.width / 2, Screen.height / 2, 0))
    if bx and by then
        cx, cy = bx, by
    else
        if not Single.Grid():IsHaveGrid(cx, cy) then
            cx, cy = Single.Grid():GetEmptyGrid()
        end
    end

    local queue = {}    --要查找队列
    local closeList = {}    --已查找列表
    table.insert(queue, cx .. "_" .. cy)
    local JudgmentAndAdd = function(x, y, queue)
        if Single.Grid():IsHaveGrid(x, y) then  --有效格子：格子区域数据中拿数据
            table.insert(queue, x .. "_" .. y)
        end
    end
    ---广度优先搜索算法
    while(#queue > 0) do
        local nodeKey = queue[1]
        table.remove(queue, 1)
        if closeList[nodeKey] == nil then  --不在关闭列表中
            local arr = string.Split(nodeKey, "_")
            local gx, gy = tonumber(arr[1]), tonumber(arr[2])
            if MapUtil.IsCanPlace(gx, gy, size) then     --找到结果，可放置，返回
                return true, gx, gy
            end
            closeList[nodeKey] = true
            JudgmentAndAdd((gx + 1), gy, queue)
            JudgmentAndAdd((gx - 1), gy, queue)
            JudgmentAndAdd(gx, (gy + 1), queue)
            JudgmentAndAdd(gx, (gy - 1), queue)
        end
    end
    return false, cx, cy
end

---查找治愈格子
---@return HealGridInfo
function MapUtil.FindHealInfo(x, y)
    local queue, closeList = {}, {}
    table.insert(queue, { index = -1, x = x, y = y })
    local JudgmentFunc = function(x, y, queue)
        local info = Single.Grid():GetTileInfo(x, y)
        if info and info:IsUnlock() then  --有效格子：格子区域数据中拿数据HealGridInfo
            table.insert(queue, { index = info.index, x = x, y = y, info = info })
        end
    end

    ---广度优先搜索算法
    while(#queue > 0) do
        local node = queue[1]
        table.remove(queue, 1)
        if closeList[node.index] == nil then  --不在关闭列表中
            local gx, gy = node.x, node.y
            if node.info and node.info:IsCanHeal() then     --找到结果，可放置，返回
                return Single.Grid():GetTileInfo(gx, gy)
            end
            closeList[node.index] = true
            JudgmentFunc((gx + 1), gy, queue)
            JudgmentFunc((gx - 1), gy, queue)
            JudgmentFunc(gx, (gy + 1), queue)
            JudgmentFunc(gx, (gy - 1), queue)
        end
    end

    local infoList = Single.Grid():GetAllVisibleItem(true)
    for i, v in ipairs(infoList) do
        if v:IsCanHeal() and v:IsUnlock() then
            return v
        end
    end
    return nil
end

return MapUtil

